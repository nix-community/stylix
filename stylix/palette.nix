{
  pkgs,
  lib,
  config,
  options,
  ...
}:
let
  cfg = config.stylix;
  opts = options.stylix;
in
{
  imports = lib.singleton (
    lib.mkRenamedOptionModule
      [ "stylix" "polarity" ]
      [ "stylix" "colorGeneration" "polarity" ]
  );
  options.stylix = {
    colorGeneration = {
      contrast = lib.mkOption {
        type = lib.types.addCheck lib.types.float (x: x >= -1.0 && x <= 1.0);
        default = 0.0;
        description = ''
          The contrast of the generated color scheme, ranging from `-1.0` to
          `1.0` (inclusive).
        '';
      };

      lightness = {
        dark = lib.mkOption {
          type = lib.types.addCheck lib.types.float (x: x <= 1.0);
          default = 0.0;
          description = ''
            Value from -∞ to 1. -∞ represents minimum lightness,
            0 represents standard (i.e. the design as spec'd),
            and 1 represents maximum lightness. For dark schemes,
            if the considered lightnesses are between 0 and 1 then
            this applies an affine transformation to the lightness
            by keeping the value for 1 at 1 and setting the value
            for 0 to the lightness argument and then clamping the
            result.
          '';
        };
        light = lib.mkOption {
          type = lib.types.addCheck lib.types.float (x: x >= -1.0);
          default = 0.0;
          description = ''
            Value from -1 to +∞. -1 represents minimum lightness,
            0 represents standard (i.e. the design as spec'd),
            and +∞ represents maximum lightness. For light schemes,
            if the considered lightnesses are between 0 and 1 then
            this applies an affine transformation to the lightness
            by keeping the value for 0 at 0 and setting the value
            for 1 to (1 + the lightness argument) and then clamping
            the result.
          '';
        };
      };

      filter = lib.mkOption {
        type = lib.types.enum [
          "catmull-rom"
          "gaussian"
          "lanczos3"
          "nearest"
          "triangle"
        ];
        default = "lanczos3";
        example = "nearest";
        description = ''
          [Matugen](https://github.com/InioX/matugen)'s resize filter.
        '';
      };

      polarity = lib.mkOption {
        type = lib.types.enum [
          "dark"
          "light"
        ];
        default = "dark";
        example = "light";
        description = "Whether to apply the dark or light theme.";
      };

      scheme = lib.mkOption {
        type = lib.types.enum [
          "content"
          "expressive"
          "fidelity"
          "fruit-salad"
          "monochrome"
          "neutral"
          "rainbow"
          "tonal-spot"
          "vibrant"
        ];
        default = "content";
        example = "tonal-spot";
        description = ''
          [Matugen](https://github.com/InioX/matugen)'s color scheme type.
        '';
        apply = value: "scheme-${value}";
      };
    };

    image = lib.mkOption {
      type = lib.types.nullOr lib.types.path;
      # Ensure the path is copied to the store
      apply =
        value: if value == null || lib.isDerivation value then value else "${value}";
      description = ''
        Wallpaper image.

        This is set as the background of your desktop environment, if possible,
        and used to generate a colour scheme if you don't set one manually.
      '';
      default = null;
    };

    imageScalingMode = lib.mkOption {
      type = lib.types.enum [
        "stretch"
        "fill"
        "fit"
        "center"
        "tile"
      ];
      default = "fill";
      description = ''
        Scaling mode for the wallpaper image.

        `stretch`
        : Stretch the image to cover the screen.

        `fill`
        : Scale the image to fill the screen, potentially cropping it.

        `fit`
        : Scale the image to fit the screen without being cropped.

        `center`
        : Center the image without resizing it.

        `tile`
        : Tile the image to cover the screen.
      '';
    };

    generated = {
      json = lib.mkOption {
        type = lib.types.package;
        description = "The output file produced by the palette generator.";
        readOnly = true;
        internal = true;
        # This *must* be the derivation running the palette generator,
        # and not anything indirect such as filling a template, otherwise
        # the output of the palette generator will not be protected from
        # garbage collection.
        default =
          pkgs.runCommand "palette.json"
            {
              nativeBuildInputs = [
                config.stylix.inputs.matugen.packages.${pkgs.stdenv.hostPlatform.system}.default
              ];
              env = {
                CONTRAST = toString cfg.colorGeneration.contrast;
                FILTER = cfg.colorGeneration.filter;
                IMAGE = cfg.image;
                POLARITY = cfg.colorGeneration.polarity;
                LIGHTNESSDARK = toString cfg.colorGeneration.lightness.dark;
                LIGHTNESSLIGHT = toString cfg.colorGeneration.lightness.light;
                SCHEME = cfg.colorGeneration.scheme;
              };
            }
            ''
              matugen \
                --contrast "$CONTRAST" \
                --lightness-dark "$LIGHTNESSDARK" \
                --lightness-light "$LIGHTNESSLIGHT" \
                --dry-run \
                --include-image-in-json false \
                --json strip \
                --mode "$POLARITY" \
                --resize-filter "$FILTER" \
                --type "$SCHEME" \
                image \
                "$IMAGE" |
                sed -E 's/"image":[[:space:]]*"[^"]*",?//g' \
                >$out'';
      };

      palette =
        lib.mkOption {
          type = lib.types.attrs;
          description = "The palette generated by the palette generator.";
          readOnly = true;
          internal = true;
          default =
            builtins.mapAttrs
              (
                let
                  inherit (lib.importJSON cfg.generated.json) colors;
                in
                _: color: colors.${color}.${cfg.colorGeneration.polarity}
              )
              (
                if cfg.colorGeneration.polarity == "dark" then
                  {
                    base00 = "surface_container_lowest";
                    base01 = "surface_container";
                    base02 = "surface_container_highest";
                    base03 = "outline";
                    base04 = "on_surface_variant";
                    base05 = "on_surface";
                    base06 = "secondary_fixed";
                    base07 = "primary";
                    base08 = "error";
                    base09 = "tertiary";
                    base0A = "secondary";
                    base0B = "primary";
                    base0C = "primary_fixed";
                    base0D = "surface_tint";
                    base0E = "tertiary_fixed";
                    base0F = "on_error_container";
                  }

                else
                  {
                    base00 = "surface";
                    base01 = "surface_container";
                    base02 = "surface_container_highest";
                    base03 = "outline";
                    base04 = "on_surface_variant";
                    base05 = "on_surface";
                    base06 = "tertiary_container";
                    base07 = "on_primary_fixed_variant";
                    base08 = "error";
                    base09 = "tertiary";
                    base0A = "secondary";
                    base0B = "primary";
                    base0C = "primary_container";
                    base0D = "surface_tint";
                    base0E = "secondary_fixed_dim";
                    base0F = "inverse_surface";
                  }
              );
        }
        // {
          author = "Stylix";
          scheme = "Stylix";
          slug = "stylix";
        };

      fileTree = lib.mkOption {
        type = lib.types.raw;
        description = "The files storing the palettes in json and html.";
        readOnly = true;
        internal = true;
      };
    };

    base16Scheme = lib.mkOption {
      description = ''
        A scheme following the base16 standard.

        This can be a path to a file, a string of YAML, or an attribute set.
      '';
      type =
        with lib.types;
        oneOf [
          path
          lines
          attrs
        ];
      # We add an assertion here, because this value is used throughout Stylix.
      # Using the assertions option is ineffective because it is checked after
      # the errors caused by reading `base16Scheme` have occurred.
      # See https://github.com/nix-community/stylix/pull/1408
      # and https://github.com/nix-community/stylix/pull/1446
      default =
        lib.throwIf (cfg.image == null)
          "stylix: one of `${opts.image}' or `${opts.base16Scheme}' must be set."
          cfg.generated.palette;
      defaultText = lib.literalMD ''
        Automatically selected from the background image. The default will
        throw if `config.stylix.image` is null.
      '';
    };

    override = lib.mkOption {
      description = ''
        An override that will be applied to stylix.base16Scheme when generating
        config.lib.stylix.colors.

        Takes anything that a scheme generated by base16nix can take as argument
        to override.
      '';
      type = lib.types.attrs;
      default = { };
    };

    paletteGenerator = lib.mkOption {
      description = "The palette generator executable.";
      type = lib.types.package;
      internal = true;
      readOnly = true;
    };

    base16 = lib.mkOption {
      description = "The base16.nix library.";
      internal = true;
      readOnly = true;
    };

    inputs = lib.mkOption {
      description = "Inputs of the Stylix flake.";
      internal = true;
      readOnly = true;
    };
  };

  config = {
    # This attrset can be used like a function too, see
    # https://github.com/SenchoPens/base16.nix/blob/b390e87cd404e65ab4d786666351f1292e89162a/README.md#theme-step-22
    lib.stylix.colors = (cfg.base16.mkSchemeAttrs cfg.base16Scheme).override cfg.override;

    stylix.generated.fileTree = {
      # The raw output of the palette generator.
      "stylix/generated.json" = {
        # We import the generated palette during evaluation but don't make it
        # a dependency, which means the garbage collector is free to delete it
        # immediately. Future evaluations may need to download, compile, and
        # run the palette generator from scratch to recreate the same palette.
        #
        # To improve performance, we can make the generated file part of the
        # system, which protects it from garbage collection and so increases
        # the potential for reuse between evaluations.
        #
        # The palette generator executable is not affected, and can still be
        # cleaned up as usual, so the overhead on system size is less than a
        # kilobyte.
        source = cfg.generated.json;

        # Only do this when `base16Scheme` is still the option default, which
        # is when the generated palette is used. Depending on the file in other
        # cases would force the palette generator to run when we never read the
        # output.
        #
        # Controlling this by comparing against the default value with == would
        # also force the palette generator to run, as we would have to evaluate
        # the default value to check for equality. To work around this, we
        # check only the priority of the resolved value. The priority of option
        # defaults is 1500 [1], and any value less than this means the user has
        # changed the option.
        #
        # [1]: https://github.com/NixOS/nixpkgs/blob/5f30488d37f91fd41f0d40437621a8563a70b285/lib/modules.nix#L1063
        enable = options.stylix.base16Scheme.highestPrio >= 1500;
      };

      # The current palette, with overrides applied.
      "stylix/palette.json".source = config.lib.stylix.colors {
        template = ./palette.json.mustache;
        extension = ".json";
      };

      # We also provide a HTML version which is useful for viewing the colors
      # during development.
      "stylix/palette.html".source = config.lib.stylix.colors {
        template = ./palette.html.mustache;
        extension = ".html";
      };
    };
  };
}
